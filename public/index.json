[{"categories":null,"content":"深入浅出vuejs读后感 ","date":"2020-07-28","objectID":"/feeling-of-vuejs/:0:0","tags":[],"title":"深入浅出vuejs读后感","uri":"/feeling-of-vuejs/"},{"categories":null,"content":"一次失败的购书体验 最近，通过闲鱼这个二手平台，买了本技术书籍。这是我第一次在闲鱼平台上买书。没想到，结果却这么令我不满意。 我买了本书，书名是《深入浅出vuejs》，我本以为我对书的质量要求没那么高，用二手书也可以。毕竟便宜，尽管在pdd上买正版书也不过贵了几块钱。在这样的前提下，我仍旧买了二手书，没错，就是因为它的便宜。结果，我理所当然地吃亏了。因为它是一本好书。好书是足以让我去买正版，回馈给作者的，书太贵的除外，而它只不过二十多块钱啊。 尽管我有点后悔，不过还是告诉自己没关系，因为它还能看。 我降低了自己的要求。并告诉自己，下次有钱还是买正版书把。 虽然排版是一样的，但是打印的墨水不一样吧，盗版书有个特点就是，图片很不清晰。不知道正版会不会这样，盗版就会这样。 ","date":"2020-07-28","objectID":"/feeling-of-vuejs/:1:0","tags":[],"title":"深入浅出vuejs读后感","uri":"/feeling-of-vuejs/"},{"categories":null,"content":"这本书还是很有价值的 虽然才200多页不到。但是它涵盖了vuejs的方方面面，包括面试经常问到的，vnode，patch，vue.nexttick等原理都用朴素的语言描述，文章通俗易懂。 ","date":"2020-07-28","objectID":"/feeling-of-vuejs/:2:0","tags":[],"title":"深入浅出vuejs读后感","uri":"/feeling-of-vuejs/"},{"categories":null,"content":"通过这本书弥补了之前不足的知识 有人可能会说，自己用的是react技术栈，没用过vue，以后也不打算用vue，所以不看。我认为这个观点是错误的。除了涉及vuejs外，这本书还涉及了，js原本的知识。包括执行栈，eventloop等。 ","date":"2020-07-28","objectID":"/feeling-of-vuejs/:3:0","tags":[],"title":"深入浅出vuejs读后感","uri":"/feeling-of-vuejs/"},{"categories":null,"content":"仍没看完 看完之后再补坑把。 ","date":"2020-07-28","objectID":"/feeling-of-vuejs/:4:0","tags":[],"title":"深入浅出vuejs读后感","uri":"/feeling-of-vuejs/"},{"categories":null,"content":"五分钟带你了解CDN。","date":"2020-07-09","objectID":"/cdn/","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":" 五分钟带你了解CDN。 ","date":"2020-07-09","objectID":"/cdn/:0:0","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"是什么？ CDN（Content Delivery Network），即内容分发网络。 ","date":"2020-07-09","objectID":"/cdn/:1:0","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"原理 尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。 通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。 ","date":"2020-07-09","objectID":"/cdn/:2:0","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"过程 当用户点击APP上的内容，APP会根据URL地址去本地DNS（域名解析系统）寻求IP地址解析。 本地DNS系统会将域名的解析权交给CDN专用DNS服务器。 CDN专用DNS服务器，将CDN的全局负载均衡设备IP地址返回用户。 用户向CDN的负载均衡设备发起内容URL访问请求。 CDN负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的缓存服务器。 负载均衡设备告诉用户这台缓存服务器的IP地址，让用户向所选择的缓存服务器发起请求。 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。 如果这台缓存服务器上并没有用户想要的内容，那么这台缓存服务器就要网站的源服务器请求内容。 源服务器返回内容给缓存服务器，缓存服务器发给用户，并根据用户自定义的缓存策略，判断要不要把内容缓存到缓存服务器上。 ","date":"2020-07-09","objectID":"/cdn/:3:0","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"目的 使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。 内容有吸引力 访问速度快 支持频繁的用户互动 可以在各处浏览无障碍 ","date":"2020-07-09","objectID":"/cdn/:4:0","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"回源问题 ","date":"2020-07-09","objectID":"/cdn/:5:0","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"回源是什么？ 客户端请求资源，在DNS缓存服务器上找不到对应资源，然后到上一级服务器上面找，递归下去，如果一直没有找到，就会到服务端地址上面请求资源。这就是回源。 ","date":"2020-07-09","objectID":"/cdn/:5:1","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"原因 缓存失效（超出缓存时间，缓存内容变更等 缓存资源不存在 资源不缓存 ","date":"2020-07-09","objectID":"/cdn/:5:2","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"劫持 ","date":"2020-07-09","objectID":"/cdn/:6:0","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"CDN劫持发生的原因？ 一般情况下，在我们访问cdn服务器的时候，请求是https的，这个时候没发生劫持，在我们更改文件的时候，cdn服务器上没有对应资源，发生回源，用http访问服务器的时候，发生了劫持。 ","date":"2020-07-09","objectID":"/cdn/:6:1","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"如何解决 利用SRI script标签上有个属性，作用是防止篡改。 举个栗子： \u003cscript type=\"text/javascript\" src=\"//s.url.cn/xxxx/aaa.js\" integrity=\"sha256-xxx sha384-yyy\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e ","date":"2020-07-09","objectID":"/cdn/:6:2","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"不适合使用的场景 具有强针对性的和特定的小范围用户群 极端本地化用户群 监管和复杂的治理要求 ","date":"2020-07-09","objectID":"/cdn/:7:0","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"参考文章 https://www.zhihu.com/question/36514327/answer/193768864 https://developer.mozilla.org/zh-CN/docs/Web/Security/%E5%AD%90%E8%B5%84%E6%BA%90%E5%AE%8C%E6%95%B4%E6%80%A7 ","date":"2020-07-09","objectID":"/cdn/:8:0","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"十分钟带你了解JS中的位运算。","date":"2020-07-08","objectID":"/bit-calculate-in-js/","tags":["web"],"title":"聊聊「位运算」","uri":"/bit-calculate-in-js/"},{"categories":null,"content":" 十分钟带你了解JS中的位运算。 ","date":"2020-07-08","objectID":"/bit-calculate-in-js/:0:0","tags":["web"],"title":"聊聊「位运算」","uri":"/bit-calculate-in-js/"},{"categories":null,"content":"在JS中的表示 二进制0b开头 八进制0开头 十六进制0x开头 var a = 0b111; var b = 017; var c = 0xF; console.log(a,b,c); // 7, 15, 15 ","date":"2020-07-08","objectID":"/bit-calculate-in-js/:1:0","tags":["web"],"title":"聊聊「位运算」","uri":"/bit-calculate-in-js/"},{"categories":null,"content":"进制转换 十进制转二进制 console.log(Number(3).toString(2)); // 11 二进制转十进制 // parseInt(数值, 进制数) console.log(parseInt(3,2)); // 11 小数转二进制（乘2取整） // 0.1 0.1 * 2 = 0.2 // 0 0.2 * 2 = 0.4 // 0 0.4 * 2 = 0.8 // 0 0.8 * 2 = 1.6 // 1 0.6 * 2 = 1.2 // 1 0.2 * 2 = 0.4 // 0 // ... 二进制转整数（除2取余） // 11 11 / 2 = 5 // 1 5 / 2 = 2 // 1 2 / 2 = 1.25 // 1 // 1 + 1 + 1 = 3 ","date":"2020-07-08","objectID":"/bit-calculate-in-js/:2:0","tags":["web"],"title":"聊聊「位运算」","uri":"/bit-calculate-in-js/"},{"categories":null,"content":"按位操作符 别称 运算符 示例 描述 按位与 \u0026 a\u0026b 对于每个比特位， 只有两个操作数相应的比特位都是1时，结果才为1，否则为0。 按位或 | a|b 对于每个比特位， 当两个操作数相应的比特位至少有一个1时，结果为1，否则为0。 按位异或 ^ a^b 对于每个比特位， 当两个操作数相应的比特位有且只有一个1时，结果为1，否则为0。 左移 « a«b 左移b (\u003c 32) 比特位，右边用0代替。 有符号右移 » a»b 右移b (\u003c 32) 比特位，丢弃被移出的位。 无符号右移 »\u003e a»\u003eb 右移b(\u003c 32) 比特位，丢弃被移出的位，并使用 0 在左侧填充。 按位非 ~ ~a 对于每个比特位，反转操作数的比特位，即0变成1，1变成0。 ","date":"2020-07-08","objectID":"/bit-calculate-in-js/:3:0","tags":["web"],"title":"聊聊「位运算」","uri":"/bit-calculate-in-js/"},{"categories":null,"content":"一些在JS中的技巧 取奇偶 console.log(7\u00261); // 1 console.log(4\u00261); // 0 取整 console.log(~~7.77); // 7 console.log(7.77\u003c\u003c0); // 7 console.log(7.77\u003e\u003e0); // 7 ","date":"2020-07-08","objectID":"/bit-calculate-in-js/:4:0","tags":["web"],"title":"聊聊「位运算」","uri":"/bit-calculate-in-js/"},{"categories":null,"content":"运用 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 var isValidSudoku = function(board) { const bitMap = [0,0,0,0,0,0,0,0,0]; for (let row = 0; row \u003c 9; row++) { for (let col = 0; col \u003c 9; col++) { if (board[row][col] === '.') continue; const moveBit = Number(board[row][col]) - 1; const rowFlag = 1 \u003c\u003c moveBit; const colFlag = 1 \u003c\u003c 9 \u003c\u003c moveBit; const subFlag = 1 \u003c\u003c 9 \u003c\u003c 9 \u003c\u003c moveBit; const subIndex = parseInt(row / 3, 10) * 3 + parseInt(col / 3, 10); if (((bitMap[row] \u0026 rowFlag) === rowFlag) || ((bitMap[col] \u0026 colFlag) === colFlag) || ((bitMap[subIndex] \u0026 subFlag) === subFlag) ) { return false; } bitMap[row] |= rowFlag; bitMap[col] |= colFlag; bitMap[subIndex] |= subFlag; } } return true; }; 这里来解释一下上面这个算法。 首先这里的bitmap代表的是什么呢？这也是我一开始看不懂这个答案的主要点。 它指的是，这个二维数组的地图。也就是说，第一列和第一行的所有数都会设置到bitmap地图的第一个数中。第二列和第二行的所有数都会设置到bitmap的第二个数中。于此类推，第九列和第九行的所有数都会设置到bitmap的第九个数中。 从代码块来看一下，设置数的时候分别干了什么？ const moveBit = Number(board[row][col]) - 1; const rowFlag = 1 \u003c\u003c moveBit; const colFlag = 1 \u003c\u003c 9 \u003c\u003c moveBit; const subFlag = 1 \u003c\u003c 9 \u003c\u003c 9 \u003c\u003c moveBit; const subIndex = parseInt(row / 3, 10) * 3 + parseInt(col / 3, 10); if (((bitMap[row] \u0026 rowFlag) === rowFlag) || ((bitMap[col] \u0026 colFlag) === colFlag) || ((bitMap[subIndex] \u0026 subFlag) === subFlag) ) { return false; } bitMap[row] |= rowFlag; bitMap[col] |= colFlag; bitMap[subIndex] |= subFlag; 这里是什么意思呢？ 我们都知道0-9，是9个不同的数字，分别对应bitmap 000000000|00000000|000000000 中的每位数。先忽略最左边部分的情况下（这部分另外提出讨论），比如我dp(1,1)为8，那么bitmap就会变成 000000000|000000010|000000010 同理，如果dp(1,2)为8的话，那么就会在设置bitmap的时候发现同样位置上已经有个1占位了。那么就会执行判断条件 if (((bitMap[row] \u0026 rowFlag) === rowFlag) || ((bitMap[col] \u0026 colFlag) === colFlag) || ((bitMap[subIndex] \u0026 subFlag) === subFlag) ) { return false; } 返回false。那么接下来，我们看看第一部分。九宫格的数字怎么单独隔离出来呢？看下代码。 const subIndex = parseInt(row / 3, 10) * 3 + parseInt(col / 3, 10); 我们先想象一下，一个9X9的数组是不应该有9个9宫格。那么就很清晰了。首先，第一个九宫格的区域范围可以表示为在这个区间范围内row:[0-2],col:[0-2]；也就是说，这个范围内的所有数都应该在bitmap中的第一个数中。 所以上面的公式就这样的出来了。我们验证一下这个公式。 const subIndex = parseInt(row / 3, 10) * 3 + parseInt(col / 3, 10); //输入dp(1,1) 返回 0 // dp(2,0) returns 0 // dp(7,8) returns 9 // dp(8,8) returns 9 好的，那么这个bitmap算法就完成拉。 感谢看到这里的朋友。希望看完这篇文章能给大家一点收获。 ","date":"2020-07-08","objectID":"/bit-calculate-in-js/:5:0","tags":["web"],"title":"聊聊「位运算」","uri":"/bit-calculate-in-js/"},{"categories":null,"content":"参考 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators https://leetcode-cn.com/problems/valid-sudoku/ https://www.w3school.com.cn/js/js_obj_number.asp ","date":"2020-07-08","objectID":"/bit-calculate-in-js/:6:0","tags":["web"],"title":"聊聊「位运算」","uri":"/bit-calculate-in-js/"},{"categories":null,"content":"休息了挺长一段时间，然后也去找面试机会，来试下自己最近的复习效果。 先说结论， 不理想。接下来，是对这次面试的复盘。 ","date":"2020-07-02","objectID":"/interview-replay/:0:0","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"为何不理想？ 因为，面试官问的问题，普遍比较简单，然后我还没有答上来，这是让我最失望的一个点。 要说紧张，有一部分把，但主要还是自己没复习到位。 然后，打算下次面试前，先自己模拟一下面试，自己先把答案记录下来，发现有什么不足的再完善， 可能这样的效果会好很多。 ","date":"2020-07-02","objectID":"/interview-replay/:1:0","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"面对hr的问题 问前两家公司不是破产就是资金不足。。可能会怀疑自己把。。 不过，我也是实话实说啊。。我还有讨工资的证据呢。。要不拿出来看看？？233 对，我就是这么不幸运。我已经解释过很多次了，如果还是不相信的话，那么就随缘把。。 ","date":"2020-07-02","objectID":"/interview-replay/:2:0","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"你的职业规划是如何 我： 3年达到高级，现在阶段是初中级，面临瓶颈期 hr： 那么还有点远 我： 。。。 其实这里我应该换套话，举个栗子， 3年到高级，我现在是中级。 而不应该说自己达到了瓶颈期，卡在初中级的水平。这样hr误以为我还没达到中级。停留在初级，拿不到期望的薪资水平。 这里是我的问题，先记录下来。 ","date":"2020-07-02","objectID":"/interview-replay/:2:1","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"现在对公司的期待是如何 我： 氛围，感觉最重要 hr： ********** 我： 。。。我没想太多，就是看感觉 hr： ******* 我： 嗯嗯，你说得对 其实这里， 我可能要说， 看技术氛围。 要实现的效果是， 让hr听不懂， 又觉得有一定的合理性。 这里做得也不好， 记录下。 ","date":"2020-07-02","objectID":"/interview-replay/:2:2","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"你还有什么想问的 ","date":"2020-07-02","objectID":"/interview-replay/:3:0","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"技术方面： 大概多久组织一次技术会议 关于cr 关于监控平台 bff部分的搭建 ","date":"2020-07-02","objectID":"/interview-replay/:3:1","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"工作方面 福利，比如团建 关于调薪 ","date":"2020-07-02","objectID":"/interview-replay/:3:2","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"部分面试问题 ","date":"2020-07-02","objectID":"/interview-replay/:4:0","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"setState 是同步还是异步的 先说结论： 合成事件中是异步的 生命周期中是异步的 原生事件中是同步的 宏任务中是同步的 平时用到最多的情况，就是作为asynchronous的情况，还有宏任务里作为async的情况。 ","date":"2020-07-02","objectID":"/interview-replay/:5:0","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"面对对象和面对过程的理解 当被问到这个问题的时候，我的大脑首先思考的是，面对对象解决的是什么问题，面对过程呢？ 然后就陷入了一个死循环，当时没有及时跳出来。 现在的话，感觉还是答不出来。 面对对象， 对象，原型，多态，封装。。 感觉不能再深入了，基础被吊打。 ","date":"2020-07-02","objectID":"/interview-replay/:6:0","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"说说redux是怎么设计的 这块，我是会写redux的，可是面试官是让我表述，突然就感觉鸭梨来了。就是说，动手能力，还行，可是表述能力欠佳把。 用观察者模式设计的。构造的时候，会生成一个store，用来存储数据。另外会暴露出内部的方法来获取或者改变store。 还提供了，订阅的方式来订阅一个reducer队列，然后到dipatch的时候，遍历队列并把最新的store传染到reducer里面。 ","date":"2020-07-02","objectID":"/interview-replay/:7:0","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"正则筛选中文 。。。我正准备写的时候，想了下中文的aci2码是多少，完全记不住啊 百度一下，是这个， const reg = /[\\u4e00-\\u9fa5]+/; const reg1 = /[^\\x00-\\xff]+/ console.log(reg.test('我是中文')); // true console.log('我是中文'.match(reg)); // Array[0] '我是中文' ","date":"2020-07-02","objectID":"/interview-replay/:8:0","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"你做过什么优化性能的事情 压缩img 对于公共库和静态资源， 引入cdn 内存占用的问题，内存溢出优化 其实这里还可以有更多的展开。 举个栗子， 往webpack上面扯， webpack的构建优化， 结合file-loader的压缩图片等。 ","date":"2020-07-02","objectID":"/interview-replay/:9:0","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"你觉得2020年前端区域的发展趋势 前端微服务 http2的引入 serverless，即 函数即服务 ","date":"2020-07-02","objectID":"/interview-replay/:10:0","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"http2和http1的区别 ","date":"2020-07-02","objectID":"/interview-replay/:11:0","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"http 1.1 缺点： TCP连接数限制 浏览器tcp连接数限制是6-8。超过这个连接数会等待之前的dns，tcp解析完再解析后面的tcp，每次解析都会浪费一定的时间。 线头阻塞问题 等http响应回来再执行另一个request，如果多个阻塞就行导致线头阻塞。 ","date":"2020-07-02","objectID":"/interview-replay/:11:1","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"http2.0 优点： 多路复用 解决了http1.1线头阻塞的问题。 HTTP1 的几种优化可以弃用 合并文件、内联资源、雪碧图、域名分片对于 HTTP/2 来说是不必要的，使用 h2 尽可能将资源细粒化，文件分解地尽可能散，不用担心请求数多。 数据帧格式 使用数据帧替代了之前的明文传输格式。多了个xx字段。。 ","date":"2020-07-02","objectID":"/interview-replay/:11:2","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"说说MVC和MVVM的区别，react和vue的区别 什么是MVC, MVVM MVC model，负责数据的存放。 view，负责展示数据。 controller，负责控制逻辑，输出给view MVVM model， view， viewModel，降低controller的概念 ","date":"2020-07-02","objectID":"/interview-replay/:12:0","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"CSS权重 !important \u003e 内联 \u003e id \u003e class 也有id100，class10，tag1的这种说法 ","date":"2020-07-02","objectID":"/interview-replay/:13:0","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"模块化和组件化带来的好处 什么是模块 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起 块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信 模块化进化史 全局function namespace IIFE 模块化 优点 避免命名冲突(减少命名空间污染) 更好的分离, 按需加载 更高复用性 高可维护性 避免script过多而导致的请求数过多，从而提高性能 难以维护 我理解的组件化的好处应该是跟模块化相似的 ","date":"2020-07-02","objectID":"/interview-replay/:14:0","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"动态表单设计（高阶组件的使用场景） 这部分，我先看下antd的源码。 ","date":"2020-07-02","objectID":"/interview-replay/:15:0","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"移动端1px问题产生的原因 物理像素 部分机型显示不了0.5px ","date":"2020-07-02","objectID":"/interview-replay/:16:0","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"说说eventloop 浏览器中的eventloop 主线程 -\u003e 宏任务 -\u003e 微任务 -\u003e 主线程 用自己的话来描述： js在主线程执行代码，遇到宏任务（setTimeout，setInterval）会推入宏任务队列，微任务（Promise）则推入微任务队列。 等到主线程代码执行完。执行异步任务。检查微任务队列，若非空，则遍历微任务队列，并清空。 等第二步结束。检查宏任务队列，若非空，遍历宏任务队列，若宏任务中出现微任务，推入微任务队列，并执行第二步。 等异步任务完成。执行主线程的其他代码。 ","date":"2020-07-02","objectID":"/interview-replay/:17:0","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"说说webpack流程 注入参数。把plugin，loader以及自身webpck.config的参数注入到构造函数中。 开始编译。同时加载plugins。 确认入口。 根据loader解析对应文件。 结束编译。 输出文件。 输出完成。 ","date":"2020-07-02","objectID":"/interview-replay/:18:0","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"捕获和冒泡的过程 捕获 -\u003e js解析 -\u003e 冒泡 -\u003e js解析 -\u003e 捕获 ","date":"2020-07-02","objectID":"/interview-replay/:19:0","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"OOP OOP即面对对象的思想。赋予函数更多的特性，来应对更多的问题。包含，多态，封装，构造函数等特性。 ","date":"2020-07-02","objectID":"/interview-replay/:20:0","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"后面的打算 可能会整理一些前端的面试题，自己继续模拟下面试，感觉有面试的推动下，应该能更快找到工作 参考 beware-react-setstate-is-asynchronous 模块化进化史 ","date":"2020-07-02","objectID":"/interview-replay/:20:1","tags":["interview"],"title":"小公司前端面试经历","uri":"/interview-replay/"},{"categories":null,"content":"We'd love to hear from you","date":"2020-06-26","objectID":"/how-to-build-blog/","tags":["record"],"title":"How to Build Blog","uri":"/how-to-build-blog/"},{"categories":null,"content":" 一天，小明逛论坛的时候无意点开别人的blog，好漂亮，我也想整一个！之后，一篇踩坑文章指北就此诞生。 首先，推荐区wordpress上看自己喜欢的主题，然后根据官网的教程，搭建博客。 域名的话，如果不想花钱，可以到freenom.com上面购买。 如果想要形如 .com后缀的话，则需要花钱，推荐去namesilo.com上购买。 最近在腾讯云好像有搞优惠，买服务器赠送.com的域名。不过上面看.com的域名需要23元一年。也还好。 ","date":"2020-06-26","objectID":"/how-to-build-blog/:0:0","tags":["record"],"title":"How to Build Blog","uri":"/how-to-build-blog/"},{"categories":null,"content":"第一步：购买域名 购买域名的话，我是直接在namesilo.com上面买的，价格不贵，我买的是.cc后缀，当时汇率大约7，也就20块钱左右。之前在freenom上注册过几次，都被说是机器人，不给注册，所以就放弃了。 ","date":"2020-06-26","objectID":"/how-to-build-blog/:0:1","tags":["record"],"title":"How to Build Blog","uri":"/how-to-build-blog/"},{"categories":null,"content":"第二步：搭建博客 因为我自己是用hugo搭建的，所以会讲hugo，之前用过hexo，搭建也很简单。不过这里，就只讲hugo好了。 ","date":"2020-06-26","objectID":"/how-to-build-blog/:0:2","tags":["record"],"title":"How to Build Blog","uri":"/how-to-build-blog/"},{"categories":null,"content":"第三步：选择一个博客主题 在网站上选择https://themes.gohugo.io/，现在用的主题是LoveIt。 git clone https://.. ","date":"2020-06-26","objectID":"/how-to-build-blog/:0:3","tags":["record"],"title":"How to Build Blog","uri":"/how-to-build-blog/"},{"categories":null,"content":"第四步：发布内容 hugo新建文件的话，一行代码。 hugo new posts/first-post.md 之后就在md文件里写作就可以了，非常方便。 预览也很简单。也是一行。 hugo server 输入命令后，在浏览器上打开localhost:1313即可看到自己的博客。 ","date":"2020-06-26","objectID":"/how-to-build-blog/:0:4","tags":["record"],"title":"How to Build Blog","uri":"/how-to-build-blog/"},{"categories":null,"content":"第五步：注册github 因为我这里用的是githubPages来搭建静态博客，所以只介绍githubPages这一种方法，另外还有gitee，ve， 这里就不作比较了，网上的说法是gitee在国内比较快，ve的话比较推荐，githubPages的话访问会比较慢，不过我用了一段时间，发现其实并不慢，满足我的需求，所以就没有去更换了。 ","date":"2020-06-26","objectID":"/how-to-build-blog/:0:5","tags":["record"],"title":"How to Build Blog","uri":"/how-to-build-blog/"},{"categories":null,"content":"第六步：dnspod 这里我之前是用腾讯的dnspod来更改dns节点的。直到后来发现cloudflare也有这个功能。 ","date":"2020-06-26","objectID":"/how-to-build-blog/:0:6","tags":["record"],"title":"How to Build Blog","uri":"/how-to-build-blog/"},{"categories":null,"content":"第七步：cloudflare 到了这一步，就是更改dns节点，以及挂上https了。cloudflare还可以看到访问流量。按照网上的教程，配置一下就实现了。 ","date":"2020-06-26","objectID":"/how-to-build-blog/:0:7","tags":["record"],"title":"How to Build Blog","uri":"/how-to-build-blog/"},{"categories":null,"content":"第八步：修改主题样式 有些博客主题难免会有样式不符合自己审美的情况，这个时候就要学习一点html的知识，去改变样式。其实也很简单。如果不想改的话，直接换主题就是了，我是后者，后来换成了现在这个主题，还凑合把。 ","date":"2020-06-26","objectID":"/how-to-build-blog/:0:8","tags":["record"],"title":"How to Build Blog","uri":"/how-to-build-blog/"},{"categories":null,"content":"hello world ","date":"2020-06-24","objectID":"/first-post/:1:0","tags":null,"title":"First Post","uri":"/first-post/"},{"categories":null,"content":"我叫stein。大学读了四年土木，迷茫过，也挣扎过，最后发现自己喜欢计算机。 下过工地，考过研，最终都以失败告终。 顺着自己的兴趣，来到了互联网行业，希望能通过这个博客给我那群不懂编程的朋友一些有趣的计算机知识。 不断暴露自己，记录当下的生活和乐趣，这样看起来生活可能并没那么苦。 keep calm， keep passion。 ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"}]