[{"categories":[],"content":"你将会获得一系列视频片段，这些片段来自于一项持续时长为 T 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。","date":"2020-10-25","objectID":"/1024-video-clips/","tags":["algo"],"title":"LeetCode-1024 视频切片","uri":"/1024-video-clips/"},{"categories":[],"content":"你将会获得一系列视频片段，这些片段来自于一项持续时长为 T 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。 视频片段 clips[i] 都用区间进行表示：开始于 clips[i][0] 并于 clips[i][1] 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。 我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, T]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/video-stitching 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ","date":"2020-10-25","objectID":"/1024-video-clips/:0:0","tags":["algo"],"title":"LeetCode-1024 视频切片","uri":"/1024-video-clips/"},{"categories":[],"content":"动态规划 首先说说动态规划解决了哪些问题？ 解决了重叠子问题。那么此题目中，有哪些重叠子问题，以及如何解决重叠子问题？ ","date":"2020-10-25","objectID":"/1024-video-clips/:1:0","tags":["algo"],"title":"LeetCode-1024 视频切片","uri":"/1024-video-clips/"},{"categories":[],"content":"发现重叠子问题 先说说我的思路，如果是人为计算的话，会先找出开头[0, x]的一个clip， 然后在找另一个clip，并且这个clip 的要求是这样的，cur[0] \u003e prev[0] \u0026\u0026 cur[1] \u003e pre[1] \u0026\u0026cur[0] ≤ prev[0] 。 后来我发现，这样解下去，只能是个暴力法。并不是最优解的解法。 仔细分析不难发现，视频切片是要填满 T 时间的。这是主线问题。 重叠子问题就是，如何找到对应的切片来填满这个T 时间。 我们可以用一个 dp 来模拟主问题。 然后每个子问题的答案都可以从dp中找到。 // 主线问题 const dp = new Array(T).fill(Infinity); ","date":"2020-10-25","objectID":"/1024-video-clips/:1:1","tags":["algo"],"title":"LeetCode-1024 视频切片","uri":"/1024-video-clips/"},{"categories":[],"content":"计算 状态转移方程 dp 里的每个切片，应该是被包含在clips当中的。 这句话翻译成代码，就是 for(let i = 0; i \u003c= T; i ++) { if( i \u003e clip[0] \u0026\u0026 i \u003c clip[1] ) { dp[i] = Math.min(dp[i], dp[clip[0]] + 1) } } 这里为何要加 1 呢？加1代表，在此最优解方法上，会加 1步的 路径。换句话来说就是到达目的地的路径会由这些路径组成。那么到达T的时候，路径就会补全成为 答案所要求的路径数，也就是数组的长度。 得到这段代码后，其实状态转移方程也出来了。 就是 代码块中的dp[i] = Math.min(dp[i], dp[clip[0]] + 1) ","date":"2020-10-25","objectID":"/1024-video-clips/:1:2","tags":["algo"],"title":"LeetCode-1024 视频切片","uri":"/1024-video-clips/"},{"categories":[],"content":"得出答案前，先对base case进行查验 这里有哪些base case呢？ dp[0] = 0 因为 dp 是模拟 时间段的，起点必须是0， 终点必须是 T。如果没到达终点，dp[T] 也就是 -1。 那么另外一个base case也出来了。 return dp[T] == Infinity ? -1 : dp[T] 那么一道题就这样结束了。这里列下完整代码。（这里只列出主代码部分） const dp = new Array(T).fill(Infinity) dp[0] = [0] for(let i = 0; i \u003c= T; i ++) { if( i \u003e clip[0] \u0026\u0026 i \u003c clip[1] ) { dp[i] = Math.min(dp[i], dp[clip[0]] + 1) } } return dp[T] == Infinity ? -1 : dp[T] ","date":"2020-10-25","objectID":"/1024-video-clips/:1:3","tags":["algo"],"title":"LeetCode-1024 视频切片","uri":"/1024-video-clips/"},{"categories":[],"content":"小结 这里用暴力法的话，其实也可以，不过时间复杂度和空间复杂度这块肯定会高上不少。 这里留下一个问题，就是这种解法，用时哪种数据结构来解决问题的呢？ ","date":"2020-10-25","objectID":"/1024-video-clips/:1:4","tags":["algo"],"title":"LeetCode-1024 视频切片","uri":"/1024-video-clips/"},{"categories":[],"content":"贪心算法 前面说到了比较容易想到的动态规划的解法。那么下面来说说一个优化版的动规解法。 上面一个解法仍然可以优化，怎么优化呢？这个时候我们该想到用，状态压缩的方式。 也就是得出状态压缩方程。 ","date":"2020-10-25","objectID":"/1024-video-clips/:2:0","tags":["algo"],"title":"LeetCode-1024 视频切片","uri":"/1024-video-clips/"},{"categories":[],"content":"优化 如何进行优化？ 其实就是不必利用dp 来存储状态，而是只需要记录一个合适的状态即可。 因为 每个能到达终点T的最优解，要想尽早到达终点T， 那么每个切片的长度就需要足够长，或者更长，这就是贪心算法的核心。 因此得出这段代码。 const maxn = new Array(T).fill(0) for(const clip of clips){ if(clip[0] \u003c T) { maxn[clip[0]] = Math.max(maxn[clip[0], clip[1]]) } } ","date":"2020-10-25","objectID":"/1024-video-clips/:2:1","tags":["algo"],"title":"LeetCode-1024 视频切片","uri":"/1024-video-clips/"},{"categories":[],"content":"得出状态压缩方程 接下来的工作很简单，就是从之前得出的数组里取出一段最短到达终点T的路径。 这里需要用到一个last来存储当前片段的结尾 以及 prev 来记录当i到达结尾时last的状态， res 来记录路径数。 因此得出这样一段代码 let last = 0, prev = 0, res = 0 for(let i = 0; i \u003c= T; i++) { last = Math.max(last, maxn[i]) if(prev == i){ res++ prev = last } } ","date":"2020-10-25","objectID":"/1024-video-clips/:2:2","tags":["algo"],"title":"LeetCode-1024 视频切片","uri":"/1024-video-clips/"},{"categories":[],"content":"base case 考虑到可能会存在无法到达终点T的条件。就是当 last == Math.max(last, maxn[i])的时候，意味着last已经是最接近T的值了，但没到达。所以会返回 -1。用代码表示的话是这样， if( last == i) { return -1 } ","date":"2020-10-25","objectID":"/1024-video-clips/:2:3","tags":["algo"],"title":"LeetCode-1024 视频切片","uri":"/1024-video-clips/"},{"categories":[],"content":"完整代码 const maxn = new Array(T).fill(0) for(const clip of clips){ if(clip[0] \u003c T) { maxn[clip[0]] = Math.max(maxn[clip[0], clip[1]]) } } let last = 0, prev = 0, res = 0 for(let i = 0; i \u003c= T; i++) { last = Math.max(last, maxn[i]) if( last == i) { return -1 } if(prev == i){ res++ prev = last } } ","date":"2020-10-25","objectID":"/1024-video-clips/:2:4","tags":["algo"],"title":"LeetCode-1024 视频切片","uri":"/1024-video-clips/"},{"categories":[],"content":"总结 其实读懂题目之后，解决问题并不困难。难是难在题没读懂就开始动手做题，结果用了暴力法，半天没想出答案。更加浪费精力和拖低效率。 上面的解法是参考 LeetCode上官方解析做出的 自己的理解。 可能存在理解错误的地方，欢迎指出。 ","date":"2020-10-25","objectID":"/1024-video-clips/:3:0","tags":["algo"],"title":"LeetCode-1024 视频切片","uri":"/1024-video-clips/"},{"categories":[],"content":"将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起，块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信。 ","date":"2020-10-21","objectID":"/liao-liao-module/:0:0","tags":["”web"],"title":"聊聊 module","uri":"/liao-liao-module/"},{"categories":[],"content":"进化史 全局function namespace IIFE 模块化 ","date":"2020-10-21","objectID":"/liao-liao-module/:1:0","tags":["”web"],"title":"聊聊 module","uri":"/liao-liao-module/"},{"categories":[],"content":"模块化和组件化带来的好处 避免命名冲突(减少命名空间污染) 更好的分离, 按需加载 更高复用性 高可维护性 避免script过多而导致的请求数过多，从而提高性能 难以维护 ","date":"2020-10-21","objectID":"/liao-liao-module/:2:0","tags":["”web"],"title":"聊聊 module","uri":"/liao-liao-module/"},{"categories":[],"content":"模块化规范（CommonJs/AMD/CMD/ES MODULE） ","date":"2020-10-21","objectID":"/liao-liao-module/:3:0","tags":["”web"],"title":"聊聊 module","uri":"/liao-liao-module/"},{"categories":[],"content":"CommonJs 每一个文件有自己的作用域，一个文件就是一个模块，一个作用域。在服务端是同步加载的，在浏览器端是要提前编译，之后加载的。 特点 不会引起全局污染 第一次加载，取缓存结果，如果结果变更，则重新缓存 同步 范式 const Koa = require('koa'); const app = new Koa(); module.exports=app; 加载机制 输入的是被输出的值的拷贝。 ","date":"2020-10-21","objectID":"/liao-liao-module/:3:1","tags":["”web"],"title":"聊聊 module","uri":"/liao-liao-module/"},{"categories":[],"content":"AMD 以requirejs为代表。异步加载。 范式： // 暴露 define(function(){}) // 引入 require(['./a.js','./b.js'],function(){}) ","date":"2020-10-21","objectID":"/liao-liao-module/:3:2","tags":["”web"],"title":"聊聊 module","uri":"/liao-liao-module/"},{"categories":[],"content":"CMD 以seajs为代表，define提前，异步加载。 范式： // 暴露 define(function(require, exports, module){ exports.xxx = value module.exports = value }) // 引入 define(function (require) { var m1 = require('./module1') var m4 = require('./module4') m1.show() m4.show() }) ","date":"2020-10-21","objectID":"/liao-liao-module/:3:3","tags":["”web"],"title":"聊聊 module","uri":"/liao-liao-module/"},{"categories":[],"content":"ES MODULE ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。 范式： // 引入 import a from 'b'; // 暴露 export default a; ","date":"2020-10-21","objectID":"/liao-liao-module/:3:4","tags":["”web"],"title":"聊聊 module","uri":"/liao-liao-module/"},{"categories":[],"content":"es6 module 和 commonjs 的区别 commonjs输出的是值的拷贝，es6 module输出的是值的引用 commonjs是运行时加载，es6 module是编译时输出接口 ","date":"2020-10-21","objectID":"/liao-liao-module/:4:0","tags":["”web"],"title":"聊聊 module","uri":"/liao-liao-module/"},{"categories":[],"content":"commonjs ","date":"2020-10-21","objectID":"/liao-liao-module/:5:0","tags":["”web"],"title":"聊聊 module","uri":"/liao-liao-module/"},{"categories":[],"content":"require, module.exports 实则, require建造了一个闭包, 变量内部使用; ","date":"2020-10-21","objectID":"/liao-liao-module/:5:1","tags":["”web"],"title":"聊聊 module","uri":"/liao-liao-module/"},{"categories":[],"content":"require 创建了Module的函数供开发者使用 Module { id: '.', // 如果是 mainModule id 固定为 '.'，如果不是则为模块绝对路径 exports: {}, // 模块最终 exports filename: '/absolute/path/to/entry.js', // 当前模块的绝对路径 loaded: false, // 模块是否已加载完毕 children: [], // 被该模块引用的模块 parent: '', // 第一个引用该模块的模块 paths: [ // 模块的搜索路径 '/absolute/path/to/node_modules', '/absolute/path/node_modules', '/absolute/node_modules', '/node_modules' ] } ","date":"2020-10-21","objectID":"/liao-liao-module/:5:2","tags":["”web"],"title":"聊聊 module","uri":"/liao-liao-module/"},{"categories":[],"content":"require 和 Module.require Module.require 就是 require的原生引用。 它们的效果是一样的。 ","date":"2020-10-21","objectID":"/liao-liao-module/:5:3","tags":["”web"],"title":"聊聊 module","uri":"/liao-liao-module/"},{"categories":[],"content":"require.main node 通过判断 require.main.filename == 当前运行的filename 来决定是否同步运行。 例如 require(’./test’) 不是同步。而node filename 是。 ","date":"2020-10-21","objectID":"/liao-liao-module/:5:4","tags":["”web"],"title":"聊聊 module","uri":"/liao-liao-module/"},{"categories":[],"content":"require.cache require.cache 会把值的引用缓存起来。即使循环引用，也会优先访问这个cache里面的值，以至于不会导致循环引用的崩溃情况。 不过，也会导致线上环境不能获取最新的文件。 ","date":"2020-10-21","objectID":"/liao-liao-module/:5:5","tags":["”web"],"title":"聊聊 module","uri":"/liao-liao-module/"},{"categories":[],"content":"es6 module和commonjs 共存 实则, es6 module转化为commonjs, 成为require中的 __esModule 来存储。 require 引用 es6 中 export default 的模块的话， require(xx).default 即可。 ","date":"2020-10-21","objectID":"/liao-liao-module/:6:0","tags":["”web"],"title":"聊聊 module","uri":"/liao-liao-module/"},{"categories":[],"content":"module.exports和exports ","date":"2020-10-21","objectID":"/liao-liao-module/:7:0","tags":["”web"],"title":"聊聊 module","uri":"/liao-liao-module/"},{"categories":[],"content":"参考 https://juejin.im/post/5c17ad756fb9a049ff4e0a62 ","date":"2020-10-21","objectID":"/liao-liao-module/:8:0","tags":["”web"],"title":"聊聊 module","uri":"/liao-liao-module/"},{"categories":[],"content":" 用了很久的CSS，一直听说要使用BEM规范。这样写起来的CSS才不那么像坨翔。因此来回顾一下BEM规范。 ","date":"2020-10-18","objectID":"/liao-liao-bem/","tags":["”web"],"title":"BEM","uri":"/liao-liao-bem/"},{"categories":[],"content":"前言 用了很久的CSS，一直听说要使用BEM规范。这样写起来的CSS才不那么像坨翔。因此来回顾一下BEM规范。 ","date":"2020-10-18","objectID":"/liao-liao-bem/:1:0","tags":["”web"],"title":"BEM","uri":"/liao-liao-bem/"},{"categories":[],"content":"Block 指的是一个功能块，举个例子， .game{} .form{} 这样就是一个大块，里面还有很多的相关联的 小块。这时候要用到element。 ","date":"2020-10-18","objectID":"/liao-liao-bem/:2:0","tags":["”web"],"title":"BEM","uri":"/liao-liao-bem/"},{"categories":[],"content":"Element 指的是与功能块相关联的样式块，或者是说构成功能块里面的小功能块。举个例子， .game__header{} .form__submit{} /* less */ .game{ \u0026__header{} } .form{ \u0026__submit{} } 这样用某些预编译器能更好的耦合起来。 ","date":"2020-10-18","objectID":"/liao-liao-bem/:3:0","tags":["”web"],"title":"BEM","uri":"/liao-liao-bem/"},{"categories":[],"content":"Modifier 指的是某一样式块的状态。比如一些开关， .game{ \u0026__header{ \u0026--active{} \u0026--disabled{} } } .form{ \u0026__submit{ \u0026--active{} \u0026--disabled{} } } /* 也有这样的 */ .game{ \u0026__header{ .active{} .disabled{} } } 上面那种明显更加解耦一点。看起来也会舒服点。 ","date":"2020-10-18","objectID":"/liao-liao-bem/:4:0","tags":["”web"],"title":"BEM","uri":"/liao-liao-bem/"},{"categories":[],"content":"Reference http://getbem.com/naming/ https://css-tricks.com/bem-101/ ","date":"2020-10-18","objectID":"/liao-liao-bem/:5:0","tags":["”web"],"title":"BEM","uri":"/liao-liao-bem/"},{"categories":[],"content":" 由于没有魔女能力加持，还是好好学学类型转换。\nJS中的类型转换是出名的大坑，这里简单介绍一下JS的类型转换。","date":"2020-09-24","objectID":"/comparison-in-js/","tags":["“web"],"title":"JS中的类型转换","uri":"/comparison-in-js/"},{"categories":[],"content":"前言 从零开始的类型转换？ 由于没有魔女能力加持，还是好好学学类型转换。 JS中的类型转换是出名的大坑，这里简单介绍一下JS的类型转换。 ","date":"2020-09-24","objectID":"/comparison-in-js/:1:0","tags":["“web"],"title":"JS中的类型转换","uri":"/comparison-in-js/"},{"categories":[],"content":"JS中的类型 ","date":"2020-09-24","objectID":"/comparison-in-js/:2:0","tags":["“web"],"title":"JS中的类型转换","uri":"/comparison-in-js/"},{"categories":[],"content":"基础类型 Number String Boolean Undefined Null ","date":"2020-09-24","objectID":"/comparison-in-js/:2:1","tags":["“web"],"title":"JS中的类型转换","uri":"/comparison-in-js/"},{"categories":[],"content":"引用类型 Object（包含Function、Array） Symbol ","date":"2020-09-24","objectID":"/comparison-in-js/:2:2","tags":["“web"],"title":"JS中的类型转换","uri":"/comparison-in-js/"},{"categories":[],"content":"toString 是个内置方法，作用是转换为String类型。 栗子 const a = [1] const b = {0:1} const c = 1 const d = false a.toString() // '1' b.toString() // '[object Object]' c.toString() // '1' d.toString() // 'false' 除此之外，toString还可以注入参数。 栗子 const a = 3 const b = 10 a.toString(2) // 11 a.toString(8) // 3 b.toString(2) // 1010 b.toString(8) // 12 这里的参数ratix是数字，作用是将a转换为ratix进制的数字。如果ratix比本身的数要大的话，会返回本身。 也可以用Object.prototype.toString.call(ctx)来判断类型。 Object.prototype.toString.call(1) // [object Number] Object.prototype.toString.call([]) // [object Array] 一些不容易察觉的点 1.toString() // Invalid or unexpected token 1..toString() // '1' (1).toString() // '1' (1.).toString() // '1' ","date":"2020-09-24","objectID":"/comparison-in-js/:3:0","tags":["“web"],"title":"JS中的类型转换","uri":"/comparison-in-js/"},{"categories":[],"content":"ValueOf 返回本身。 栗子 const a = [1] const b = {0:1} const c = 1 const d = false a.valueOf() // [1] b.valueOf() // {0:1} c.valueOf() // 1 d.valueOf() // false 以及修改对象的valueOf来达到某些目的 const a = { value: 1, valueOf: function(){ return this.value++ } } a == 1 \u0026\u0026 a == 2 \u0026\u0026 a == 3 // true ","date":"2020-09-24","objectID":"/comparison-in-js/:4:0","tags":["“web"],"title":"JS中的类型转换","uri":"/comparison-in-js/"},{"categories":[],"content":"toPrimitive 返回原始值。 ","date":"2020-09-24","objectID":"/comparison-in-js/:5:0","tags":["“web"],"title":"JS中的类型转换","uri":"/comparison-in-js/"},{"categories":[],"content":"原始值 符合基础类型的被判定为原始类型。基于这些类型的值也被称为原始值。 对于引用类型而言，一般流程是： 判断类型 valueOf toString ","date":"2020-09-24","objectID":"/comparison-in-js/:5:1","tags":["“web"],"title":"JS中的类型转换","uri":"/comparison-in-js/"},{"categories":[],"content":"instanceof 和 typeof typeof 判断类型 instanceof 判断继承关系 栗子 可能没注意的坑： 在判断object类型的时候用typeof，注意把null排除掉 typeof x == 'object' \u0026\u0026 x !== null ","date":"2020-09-24","objectID":"/comparison-in-js/:6:0","tags":["“web"],"title":"JS中的类型转换","uri":"/comparison-in-js/"},{"categories":[],"content":"比较符 ","date":"2020-09-24","objectID":"/comparison-in-js/:7:0","tags":["“web"],"title":"JS中的类型转换","uri":"/comparison-in-js/"},{"categories":[],"content":"== '1' == 1 // '1'=\u003e1 != 1 =\u003e true [] == 0 // []=\u003e''=\u003e0=\u003etrue {} == 0 // {}=\u003e'[object Object]'=\u003eNaN=\u003efalse null == undefined // true 历史原因 一般流程： left和right都不是引用类型 left为String，toNumber(right) left为Boolean，toNumber(right) left为Number，toNumber(right) +0 != -0 … left和right其中一个为引用类型或者两者都是 引用类型遵循先valueOf后toString的原则转化为原始值，再根据上面的条件判断 比较特殊的: null==undefined ","date":"2020-09-24","objectID":"/comparison-in-js/:7:1","tags":["“web"],"title":"JS中的类型转换","uri":"/comparison-in-js/"},{"categories":[],"content":"=== 判断类型和值是否对等。不会进行类型转换。有一种情况除外，就是通过一些手段更改对象的get与set函数。 栗子 var value = 1 Object.defineProperty(window, 'a', { get(val){ return value++ } }) a === 1 \u0026\u0026 a === 2 \u0026\u0026 a === 3 // true ","date":"2020-09-24","objectID":"/comparison-in-js/:7:2","tags":["“web"],"title":"JS中的类型转换","uri":"/comparison-in-js/"},{"categories":[],"content":"NAN JS中比较特殊的一个关键字，就是NAN。 那么Number().isNAN()与window.isNAN()又有什么区别呢？ 看下面的几个栗子 NAN === NAN // false window.isNAN('String') // true Number.isNAN('String') // false 0/0 // NAN 0 * Infinity // NAN 至于他们有什么具体差异，因为时间关系 ","date":"2020-09-24","objectID":"/comparison-in-js/:8:0","tags":["“web"],"title":"JS中的类型转换","uri":"/comparison-in-js/"},{"categories":[],"content":"运算符号 ","date":"2020-09-24","objectID":"/comparison-in-js/:9:0","tags":["“web"],"title":"JS中的类型转换","uri":"/comparison-in-js/"},{"categories":[],"content":"+ 一般流程： left进入运算 left进行getValue right进入运算 right进行getValue left求原始值 right求原始值 left或right为String类型，则两边转化为String类型再进行求值 left或right不为String类型，toNumber然后求值 ","date":"2020-09-24","objectID":"/comparison-in-js/:9:1","tags":["“web"],"title":"JS中的类型转换","uri":"/comparison-in-js/"},{"categories":[],"content":"-、*、/ 不像+这么多功能，它们只有数字运算的功能。遇到非Number类型的值是，会先toNumber再运算取值。 ","date":"2020-09-24","objectID":"/comparison-in-js/:9:2","tags":["“web"],"title":"JS中的类型转换","uri":"/comparison-in-js/"},{"categories":[],"content":"参考 https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3 https://dmitripavlutin.com/nan-in-javascript/ ","date":"2020-09-24","objectID":"/comparison-in-js/:10:0","tags":["“web"],"title":"JS中的类型转换","uri":"/comparison-in-js/"},{"categories":[],"content":"前言 前段时间电话面试的时候面试官问了我这个问题，我当时听错了，以为问的是setState什么情况下是异步的，所以只答到了第二步，后面回想起来，好像是自己听错了，回到正题。 为了回答这个问题，我们要搞清楚， setState真的是异步的吗 setState在什么情况下是异步的 什么情况下能拿到最新的state ","date":"2020-08-21","objectID":"/why-setstate-is-asynchronous/:1:0","tags":["“web"],"title":"面试官系列之setState为何异步","uri":"/why-setstate-is-asynchronous/"},{"categories":[],"content":"setState真的是异步吗 首先先说结论，setState不是异步的。不过它看起来是异步的。为何这样说呢？ 因为react在render的时候会进入一个事务，在这个事务下，会批量更新state，在批量更新的途中如果遇到setState更改相同的键值，后者会覆盖掉前者， 这些操作让setstate看起来是异步的。 ","date":"2020-08-21","objectID":"/why-setstate-is-asynchronous/:2:0","tags":["“web"],"title":"面试官系列之setState为何异步","uri":"/why-setstate-is-asynchronous/"},{"categories":[],"content":"setState什么情况下是异步的 首先，在合成事件和生命周期中是异步的，在原生事件和settimeout中是同步的， 源码中，react通过isBatchingUpdate来判断setState是否为异步的。isBatchingUpdate默认是false的， 借用下别人的图，从图中可以很明显的看到，在合成事件和生命周期阶段，isBatchingUpdate更新为true， 进入批量更新的事务，同时setState在这个阶段中触发。因此说明了setState在这个阶段中是异步的。 （这里应该有图） ","date":"2020-08-21","objectID":"/why-setstate-is-asynchronous/:3:0","tags":["“web"],"title":"面试官系列之setState为何异步","uri":"/why-setstate-is-asynchronous/"},{"categories":[],"content":"什么情况下拿到最新的state 通过setState中第一个参数通过回调的形式能拿到最新的state。为何能拿到呢？因为源码中对参数的类型做了判断，如果是函数的话，就会给最新的更改后的state，而如果不是的话，会进入批量更新的事务中。 （这里应该有部分判断的源码） ","date":"2020-08-21","objectID":"/why-setstate-is-asynchronous/:4:0","tags":["“web"],"title":"面试官系列之setState为何异步","uri":"/why-setstate-is-asynchronous/"},{"categories":null,"content":"五分钟带你了解CDN。","date":"2020-07-09","objectID":"/cdn/","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":" 五分钟带你了解CDN。 ","date":"2020-07-09","objectID":"/cdn/:0:0","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"是什么 CDN（Content Delivery Network），即内容分发网络。 ","date":"2020-07-09","objectID":"/cdn/:1:0","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"原理 尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。 通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。 ","date":"2020-07-09","objectID":"/cdn/:2:0","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"过程 当用户点击APP上的内容，APP会根据URL地址去本地DNS（域名解析系统）寻求IP地址解析。 本地DNS系统会将域名的解析权交给CDN专用DNS服务器。 CDN专用DNS服务器，将CDN的全局负载均衡设备IP地址返回用户。 用户向CDN的负载均衡设备发起内容URL访问请求。 CDN负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的缓存服务器。 负载均衡设备告诉用户这台缓存服务器的IP地址，让用户向所选择的缓存服务器发起请求。 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。 如果这台缓存服务器上并没有用户想要的内容，那么这台缓存服务器就要网站的源服务器请求内容。 源服务器返回内容给缓存服务器，缓存服务器发给用户，并根据用户自定义的缓存策略，判断要不要把内容缓存到缓存服务器上。 ","date":"2020-07-09","objectID":"/cdn/:3:0","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"目的 使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。 内容有吸引力 访问速度快 支持频繁的用户互动 可以在各处浏览无障碍 ","date":"2020-07-09","objectID":"/cdn/:4:0","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"回源问题 ","date":"2020-07-09","objectID":"/cdn/:5:0","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"回源是什么 客户端请求资源，在DNS缓存服务器上找不到对应资源，然后到上一级服务器上面找，递归下去，如果一直没有找到，就会到服务端地址上面请求资源。这就是回源。 ","date":"2020-07-09","objectID":"/cdn/:5:1","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"原因 缓存失效（超出缓存时间，缓存内容变更等 缓存资源不存在 资源不缓存 ","date":"2020-07-09","objectID":"/cdn/:5:2","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"劫持 ","date":"2020-07-09","objectID":"/cdn/:6:0","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"CDN劫持发生的原因？ 一般情况下，在我们访问cdn服务器的时候，请求是https的，这个时候没发生劫持，在我们更改文件的时候，cdn服务器上没有对应资源，发生回源，用http访问服务器的时候，发生了劫持。 ","date":"2020-07-09","objectID":"/cdn/:6:1","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"如何解决 利用SRI script标签上有个属性，作用是防止篡改。 举个栗子： \u003cscript type=\"text/javascript\" src=\"//s.url.cn/xxxx/aaa.js\" integrity=\"sha256-xxx sha384-yyy\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e ","date":"2020-07-09","objectID":"/cdn/:6:2","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"不适合使用的场景 具有强针对性的和特定的小范围用户群 极端本地化用户群 监管和复杂的治理要求 ","date":"2020-07-09","objectID":"/cdn/:7:0","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"参考文章 https://www.zhihu.com/question/36514327/answer/193768864 https://developer.mozilla.org/zh-CN/docs/Web/Security/%E5%AD%90%E8%B5%84%E6%BA%90%E5%AE%8C%E6%95%B4%E6%80%A7 ","date":"2020-07-09","objectID":"/cdn/:8:0","tags":["web"],"title":"CDN","uri":"/cdn/"},{"categories":null,"content":"十分钟带你了解JS中的位运算。","date":"2020-07-08","objectID":"/bit-calculate-in-js/","tags":["web"],"title":"聊聊「位运算」","uri":"/bit-calculate-in-js/"},{"categories":null,"content":" 十分钟带你了解JS中的位运算。 ","date":"2020-07-08","objectID":"/bit-calculate-in-js/:0:0","tags":["web"],"title":"聊聊「位运算」","uri":"/bit-calculate-in-js/"},{"categories":null,"content":"在JS中的表示 二进制0b开头 八进制0开头 十六进制0x开头 var a = 0b111; var b = 017; var c = 0xF; console.log(a,b,c); // 7, 15, 15 ","date":"2020-07-08","objectID":"/bit-calculate-in-js/:1:0","tags":["web"],"title":"聊聊「位运算」","uri":"/bit-calculate-in-js/"},{"categories":null,"content":"进制转换 十进制转二进制 console.log(Number(3).toString(2)); // 11 二进制转十进制 // parseInt(数值, 进制数) console.log(parseInt(3,2)); // 11 小数转二进制（乘2取整） // 0.1 0.1 * 2 = 0.2 // 0 0.2 * 2 = 0.4 // 0 0.4 * 2 = 0.8 // 0 0.8 * 2 = 1.6 // 1 0.6 * 2 = 1.2 // 1 0.2 * 2 = 0.4 // 0 // ... 二进制转整数（除2取余） // 11 11 / 2 = 5 // 1 5 / 2 = 2 // 1 2 / 2 = 1.25 // 1 // 1 + 1 + 1 = 3 ","date":"2020-07-08","objectID":"/bit-calculate-in-js/:2:0","tags":["web"],"title":"聊聊「位运算」","uri":"/bit-calculate-in-js/"},{"categories":null,"content":"按位操作符 别称 运算符 示例 描述 按位与 \u0026 a\u0026b 对于每个比特位， 只有两个操作数相应的比特位都是1时，结果才为1，否则为0。 按位或 | a|b 对于每个比特位， 当两个操作数相应的比特位至少有一个1时，结果为1，否则为0。 按位异或 ^ a^b 对于每个比特位， 当两个操作数相应的比特位有且只有一个1时，结果为1，否则为0。 左移 « a«b 左移b (\u003c 32) 比特位，右边用0代替。 有符号右移 » a»b 右移b (\u003c 32) 比特位，丢弃被移出的位。 无符号右移 »\u003e a»\u003eb 右移b(\u003c 32) 比特位，丢弃被移出的位，并使用 0 在左侧填充。 按位非 ~ ~a 对于每个比特位，反转操作数的比特位，即0变成1，1变成0。 ","date":"2020-07-08","objectID":"/bit-calculate-in-js/:3:0","tags":["web"],"title":"聊聊「位运算」","uri":"/bit-calculate-in-js/"},{"categories":null,"content":"一些在JS中的技巧 取奇偶 console.log(7\u00261); // 1 console.log(4\u00261); // 0 取整 console.log(~~7.77); // 7 console.log(7.77\u003c\u003c0); // 7 console.log(7.77\u003e\u003e0); // 7 ","date":"2020-07-08","objectID":"/bit-calculate-in-js/:4:0","tags":["web"],"title":"聊聊「位运算」","uri":"/bit-calculate-in-js/"},{"categories":null,"content":"运用 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 var isValidSudoku = function(board) { const bitMap = [0,0,0,0,0,0,0,0,0]; for (let row = 0; row \u003c 9; row++) { for (let col = 0; col \u003c 9; col++) { if (board[row][col] === '.') continue; const moveBit = Number(board[row][col]) - 1; const rowFlag = 1 \u003c\u003c moveBit; const colFlag = 1 \u003c\u003c 9 \u003c\u003c moveBit; const subFlag = 1 \u003c\u003c 9 \u003c\u003c 9 \u003c\u003c moveBit; const subIndex = parseInt(row / 3, 10) * 3 + parseInt(col / 3, 10); if (((bitMap[row] \u0026 rowFlag) === rowFlag) || ((bitMap[col] \u0026 colFlag) === colFlag) || ((bitMap[subIndex] \u0026 subFlag) === subFlag) ) { return false; } bitMap[row] |= rowFlag; bitMap[col] |= colFlag; bitMap[subIndex] |= subFlag; } } return true; }; 这里来解释一下上面这个算法。 首先这里的bitmap代表的是什么呢？这也是我一开始看不懂这个答案的主要点。 它指的是，这个二维数组的地图。也就是说，第一列和第一行的所有数都会设置到bitmap地图的第一个数中。第二列和第二行的所有数都会设置到bitmap的第二个数中。于此类推，第九列和第九行的所有数都会设置到bitmap的第九个数中。 从代码块来看一下，设置数的时候分别干了什么？ const moveBit = Number(board[row][col]) - 1; const rowFlag = 1 \u003c\u003c moveBit; const colFlag = 1 \u003c\u003c 9 \u003c\u003c moveBit; const subFlag = 1 \u003c\u003c 9 \u003c\u003c 9 \u003c\u003c moveBit; const subIndex = parseInt(row / 3, 10) * 3 + parseInt(col / 3, 10); if (((bitMap[row] \u0026 rowFlag) === rowFlag) || ((bitMap[col] \u0026 colFlag) === colFlag) || ((bitMap[subIndex] \u0026 subFlag) === subFlag) ) { return false; } bitMap[row] |= rowFlag; bitMap[col] |= colFlag; bitMap[subIndex] |= subFlag; 这里是什么意思呢？ 我们都知道0-9，是9个不同的数字，分别对应bitmap 000000000|00000000|000000000 中的每位数。先忽略最左边部分的情况下（这部分另外提出讨论），比如我dp(1,1)为8，那么bitmap就会变成 000000000|000000010|000000010 同理，如果dp(1,2)为8的话，那么就会在设置bitmap的时候发现同样位置上已经有个1占位了。那么就会执行判断条件 if (((bitMap[row] \u0026 rowFlag) === rowFlag) || ((bitMap[col] \u0026 colFlag) === colFlag) || ((bitMap[subIndex] \u0026 subFlag) === subFlag) ) { return false; } 返回false。那么接下来，我们看看第一部分。九宫格的数字怎么单独隔离出来呢？看下代码。 const subIndex = parseInt(row / 3, 10) * 3 + parseInt(col / 3, 10); 我们先想象一下，一个9X9的数组是不应该有9个9宫格。那么就很清晰了。首先，第一个九宫格的区域范围可以表示为在这个区间范围内row:[0-2],col:[0-2]；也就是说，这个范围内的所有数都应该在bitmap中的第一个数中。 所以上面的公式就这样的出来了。我们验证一下这个公式。 const subIndex = parseInt(row / 3, 10) * 3 + parseInt(col / 3, 10); //输入dp(1,1) 返回 0 // dp(2,0) returns 0 // dp(7,8) returns 9 // dp(8,8) returns 9 好的，那么这个bitmap算法就完成拉。 感谢看到这里的朋友。希望看完这篇文章能给大家一点收获。 ","date":"2020-07-08","objectID":"/bit-calculate-in-js/:5:0","tags":["web"],"title":"聊聊「位运算」","uri":"/bit-calculate-in-js/"},{"categories":null,"content":"参考 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators https://leetcode-cn.com/problems/valid-sudoku/ https://www.w3school.com.cn/js/js_obj_number.asp ","date":"2020-07-08","objectID":"/bit-calculate-in-js/:6:0","tags":["web"],"title":"聊聊「位运算」","uri":"/bit-calculate-in-js/"},{"categories":null,"content":"We'd love to hear from you","date":"2020-06-26","objectID":"/how-to-build-blog/","tags":["record"],"title":"How to Build Blog","uri":"/how-to-build-blog/"},{"categories":null,"content":" 一天，小明逛论坛的时候无意点开别人的blog，好漂亮，我也想整一个！之后，一篇踩坑文章指北就此诞生。 首先，推荐区wordpress上看自己喜欢的主题，然后根据官网的教程，搭建博客。 域名的话，如果不想花钱，可以到freenom.com上面购买。 如果想要形如 .com后缀的话，则需要花钱，推荐去namesilo.com上购买。 最近在腾讯云好像有搞优惠，买服务器赠送.com的域名。不过上面看.com的域名需要23元一年。也还好。 ","date":"2020-06-26","objectID":"/how-to-build-blog/:0:0","tags":["record"],"title":"How to Build Blog","uri":"/how-to-build-blog/"},{"categories":null,"content":"第一步：购买域名 购买域名的话，我是直接在namesilo.com上面买的，价格不贵，我买的是.cc后缀，当时汇率大约7，也就20块钱左右。之前在freenom上注册过几次，都被说是机器人，不给注册，所以就放弃了。 ","date":"2020-06-26","objectID":"/how-to-build-blog/:0:1","tags":["record"],"title":"How to Build Blog","uri":"/how-to-build-blog/"},{"categories":null,"content":"第二步：搭建博客 因为我自己是用hugo搭建的，所以会讲hugo，之前用过hexo，搭建也很简单。不过这里，就只讲hugo好了。 ","date":"2020-06-26","objectID":"/how-to-build-blog/:0:2","tags":["record"],"title":"How to Build Blog","uri":"/how-to-build-blog/"},{"categories":null,"content":"第三步：选择一个博客主题 在网站上选择https://themes.gohugo.io/，现在用的主题是LoveIt。 git clone https://.. ","date":"2020-06-26","objectID":"/how-to-build-blog/:0:3","tags":["record"],"title":"How to Build Blog","uri":"/how-to-build-blog/"},{"categories":null,"content":"第四步：发布内容 hugo新建文件的话，一行代码。 hugo new posts/first-post.md 之后就在md文件里写作就可以了，非常方便。 预览也很简单。也是一行。 hugo server 输入命令后，在浏览器上打开localhost:1313即可看到自己的博客。 ","date":"2020-06-26","objectID":"/how-to-build-blog/:0:4","tags":["record"],"title":"How to Build Blog","uri":"/how-to-build-blog/"},{"categories":null,"content":"第五步：注册github 因为我这里用的是githubPages来搭建静态博客，所以只介绍githubPages这一种方法，另外还有gitee，ve， 这里就不作比较了，网上的说法是gitee在国内比较快，ve的话比较推荐，githubPages的话访问会比较慢，不过我用了一段时间，发现其实并不慢，满足我的需求，所以就没有去更换了。 ","date":"2020-06-26","objectID":"/how-to-build-blog/:0:5","tags":["record"],"title":"How to Build Blog","uri":"/how-to-build-blog/"},{"categories":null,"content":"第六步：dnspod 这里我之前是用腾讯的dnspod来更改dns节点的。直到后来发现cloudflare也有这个功能。 ","date":"2020-06-26","objectID":"/how-to-build-blog/:0:6","tags":["record"],"title":"How to Build Blog","uri":"/how-to-build-blog/"},{"categories":null,"content":"第七步：cloudflare 到了这一步，就是更改dns节点，以及挂上https了。cloudflare还可以看到访问流量。按照网上的教程，配置一下就实现了。 ","date":"2020-06-26","objectID":"/how-to-build-blog/:0:7","tags":["record"],"title":"How to Build Blog","uri":"/how-to-build-blog/"},{"categories":null,"content":"第八步：修改主题样式 有些博客主题难免会有样式不符合自己审美的情况，这个时候就要学习一点html的知识，去改变样式。其实也很简单。如果不想改的话，直接换主题就是了，我是后者，后来换成了现在这个主题，还凑合把。 ","date":"2020-06-26","objectID":"/how-to-build-blog/:0:8","tags":["record"],"title":"How to Build Blog","uri":"/how-to-build-blog/"},{"categories":null,"content":"hello world ","date":"2020-06-24","objectID":"/first-post/:1:0","tags":null,"title":"First Post","uri":"/first-post/"},{"categories":null,"content":" 我叫stein，目前是一位前端工程师 github：https://github.com/sjisntsuperman keep calm， keep passion 我们一起努力 ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About me","uri":"/about/"}]